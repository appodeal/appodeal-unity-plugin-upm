#if UNITY_ANDROID || APPODEAL_DEV
// ReSharper disable CheckNamespace

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor.Android;
using UnityEngine;
using AppodealInc.Mediation.PluginSettings.Editor;

namespace AppodealInc.Mediation.MaxAdReview.Editor
{
    internal class AndroidGradleProjectPostProcessor : IPostGenerateGradleAndroidProject
    {
        private const string CredUrl = "https://api2.safedk.com/v1/build/cred";
        private const string MaxAdapter = "com.appodeal.ads.sdk.networks:applovin_max";
        private const string PluginId = "com.applovin.quality";
        private const string OldPluginId = "applovin-quality-service";
        private const string Comment = "// Generated by Appodeal";

        private static readonly string[] LineEndingCandidates = { "\r\n", "\n" };

        public int callbackOrder => Int32.MaxValue;

        public void OnPostGenerateGradleAndroidProject(string path) => SetupMaxAdReview(path);

        private void SetupMaxAdReview(string path)
        {
            var action = AppodealSettings.Instance.IsMaxAdReviewEnabled ? PatchAction.Add : PatchAction.Remove;

            if (action == PatchAction.Add && String.IsNullOrWhiteSpace(AppodealSettings.Instance.MaxSdkKey))
            {
                AdReviewHelper.LogWarning("SDK key is missing --> disabling Ad Review");
                action = PatchAction.Remove;
            }

            if (action == PatchAction.Add)
            {
                string unityLibBuildGradleFilePath = Path.GetFullPath(Path.Combine(path, "build.gradle"));
                try
                {
                    string fileContents = File.ReadAllText(unityLibBuildGradleFilePath);
                    if (!fileContents.Contains(MaxAdapter))
                    {
                        AdReviewHelper.LogWarning("AppLovin MAX dependency not found --> disabling Ad Review");
                        action = PatchAction.Remove;
                    }
                }
                catch (Exception e)
                {
                    AdReviewHelper.LogError($"Failed to read '{unityLibBuildGradleFilePath}' to check for AppLovin MAX dependency presence --> disabling Ad Review. Error: '{e.Message}'");
                    action = PatchAction.Remove;
                }
            }

            string rootBuildGradleFilePath = Path.GetFullPath(Path.Combine(path, "..", "build.gradle"));
            string launcherBuildGradleFilePath = Path.GetFullPath(Path.Combine(path, "..", "launcher", "build.gradle"));
            string settingsGradleFilePath = Path.GetFullPath(Path.Combine(path, "..", "settings.gradle"));

            var backups = new Dictionary<string, byte[]>(StringComparer.OrdinalIgnoreCase);
            var patches = new Dictionary<string, Func<string, string, PatchAction, bool>>();

            try
            {
                backups[rootBuildGradleFilePath] = File.ReadAllBytes(rootBuildGradleFilePath);
                patches[rootBuildGradleFilePath] = PatchRootBuildGradle;

                backups[launcherBuildGradleFilePath] = File.ReadAllBytes(launcherBuildGradleFilePath);
                patches[launcherBuildGradleFilePath] = PatchLauncherBuildGradle;

                backups[settingsGradleFilePath] = File.ReadAllBytes(settingsGradleFilePath);
                patches[settingsGradleFilePath] = PatchSettingsGradleFile;
            }
            catch (Exception e)
            {
                AdReviewHelper.LogError($"Failed to read some .gradle files for patching --> disabling Ad Review. Error: '{e.Message}'");
                action = PatchAction.Remove;
            }

            foreach ((string filePath, var patchFunction) in patches)
            {
                string fileContent = Encoding.UTF8.GetString(backups[filePath]);
                bool isPatched = patchFunction(fileContent, filePath, action);

                if (isPatched) continue;

                AdReviewHelper.LogWarning($"Rolling back .gradle files due to unexpected error during patching for '{filePath}'");
                RollbackAll(backups);
                return;
            }

            if (action == PatchAction.Add) AdReviewHelper.Log("Ad Review was successfully installed");
        }

        private void RollbackAll(Dictionary<string, byte[]> backups)
        {
            foreach ((string filePath, byte[] fileContent) in backups)
            {
                try
                {
                    File.WriteAllBytes(filePath, fileContent);
                }
                catch (Exception e)
                {
                    AdReviewHelper.LogError($"Rollback failed for '{filePath}'. Error: '{e.Message}'");
                }
            }
        }

        private bool PatchRootBuildGradle(string fileContent, string filePath, PatchAction action)
        {
            string rootPluginEntry = $"    id '{PluginId}' version '+' apply false {Comment}";
            string lineEnding = LineEndingCandidates.FirstOrDefault(fileContent.Contains) ?? "\n";

            var pRegex = new Regex(@"plugins(\s*)\{", RegexOptions.Singleline);
            var pMatch = pRegex.Match(fileContent);
            if (!pMatch.Success) return false;

            int pStart = pMatch.Index;
            int pOpeningBrace = pMatch.Index + pMatch.Length - 1;

            int pClosingBrace = FindMatchingClosingBraceIndex(fileContent, pOpeningBrace);
            if (pClosingBrace < 0) return false;

            string beforeP = fileContent[..pStart];
            string pBlock  = fileContent[pStart..(pClosingBrace + 1)];
            string afterP  = fileContent[(pClosingBrace + 1)..];

            if (action == PatchAction.Remove)
            {
                if (!pBlock.Contains(Comment)) return true;
                pBlock = String.Join(lineEnding, pBlock.Split(LineEndingCandidates, StringSplitOptions.None).Where(line => !line.Contains(Comment)));
            }

            if (action == PatchAction.Add)
            {
                if (pBlock.Contains(PluginId)) return true;

                int insertPos = pOpeningBrace + 1;
                pBlock = pBlock.Insert(insertPos, $"{lineEnding}{rootPluginEntry}");
            }

            try
            {
                File.WriteAllText(filePath, beforeP + pBlock + afterP);
                return true;
            }
            catch (Exception e)
            {
                AdReviewHelper.LogError($"Patching failed for '{filePath}'. Error: '{e.Message}'");
                return false;
            }
        }

        private bool PatchLauncherBuildGradle(string fileContent, string filePath, PatchAction action)
        {
            const string applicationPlugin = "apply plugin: 'com.android.application'";

            string launcherPluginEntry = $"apply plugin: '{PluginId}' {Comment}";
            string lineEnding = LineEndingCandidates.FirstOrDefault(fileContent.Contains) ?? "\n";

            if (action == PatchAction.Remove)
            {
                if (!fileContent.Contains(Comment)) return true;
                fileContent = String.Join(lineEnding, fileContent.Split(LineEndingCandidates, StringSplitOptions.None).Where(line => !line.Contains(Comment)));
            }

            if (action == PatchAction.Add)
            {
                if (fileContent.Contains(PluginId) || fileContent.Contains(OldPluginId)) return true;

                int index = fileContent.IndexOf(applicationPlugin, StringComparison.Ordinal);
                if (index < 0) return false;

                string adReviewKey = RetrieveMaxAdReviewKey(AppodealSettings.Instance.MaxSdkKey);
                if (String.IsNullOrWhiteSpace(adReviewKey)) return false;
                string launcherApiKeyEntry = $"applovin {{ apiKey '{adReviewKey}' }} {Comment}";

                fileContent = fileContent.Insert(index + applicationPlugin.Length, $"{lineEnding}{launcherPluginEntry}{lineEnding}{launcherApiKeyEntry}");
            }

            try
            {
                File.WriteAllText(filePath, fileContent);
                return true;
            }
            catch (Exception e)
            {
                AdReviewHelper.LogError($"Patching failed for '{filePath}'. Error: '{e.Message}'");
                return false;
            }
        }

        private bool PatchSettingsGradleFile(string fileContent, string filePath, PatchAction action)
        {
            const string repoUrl = "https://artifacts.applovin.com/android";
            string settingsRepoEntry = $"        maven {{ url '{repoUrl}'; content {{ includeGroupByRegex 'com.applovin.*' }} }} {Comment}";
            string lineEnding = LineEndingCandidates.FirstOrDefault(fileContent.Contains) ?? "\n";

            var pmRegex = new Regex(@"pluginManagement(\s*)\{", RegexOptions.Singleline);
            var pmMatch = pmRegex.Match(fileContent);
            if (!pmMatch.Success) return false;

            int pmStart = pmMatch.Index;
            int pmOpeningBrace = pmMatch.Index + pmMatch.Length - 1;

            int pmClosingBrace = FindMatchingClosingBraceIndex(fileContent, pmOpeningBrace);
            if (pmClosingBrace < 0) return false;

            string beforePm = fileContent[..pmStart];
            string pmBlock = fileContent[pmStart..(pmClosingBrace + 1)];
            string afterPm = fileContent[(pmClosingBrace + 1)..];

            if (action == PatchAction.Remove)
            {
                if (!pmBlock.Contains(Comment)) return true;
                pmBlock = String.Join(lineEnding, pmBlock.Split(LineEndingCandidates, StringSplitOptions.None).Where(line => !line.Contains(Comment)));
            }

            if (action == PatchAction.Add)
            {
                if (pmBlock.Contains(repoUrl)) return true;

                var rRegex = new Regex(@"repositories\s*\{", RegexOptions.Singleline);
                var rMatch = rRegex.Match(pmBlock);
                if (!rMatch.Success) return false;

                int insertPos = rMatch.Index + rMatch.Length;
                pmBlock = pmBlock.Insert(insertPos, $"{lineEnding}{settingsRepoEntry}");
            }

            try
            {
                File.WriteAllText(filePath, beforePm + pmBlock + afterPm);
                return true;
            }
            catch (Exception e)
            {
                AdReviewHelper.LogError($"Patching failed for '{filePath}'. Error: '{e.Message}'");
                return false;
            }
        }

        private int FindMatchingClosingBraceIndex(string text, int openingBrace)
        {
            int depth = 1;
            for (int i = openingBrace + 1; i < text.Length; i++)
            {
                depth += text[i] switch
                {
                    '{' => 1,
                    '}' => -1,
                    _ => 0
                };
                if (depth == 0) return i;
            }
            return -1;
        }

        private string RetrieveMaxAdReviewKey(string sdkKey)
        {
            string postJson = $"{{\"sdk_key\":\"{sdkKey}\"}}";
            byte[] bodyRaw = Encoding.UTF8.GetBytes(postJson);

            try
            {
                var request = (HttpWebRequest)WebRequest.Create(CredUrl);
                request.Method = "POST";
                request.ContentType = "application/json";
                request.ContentLength = bodyRaw.Length;
                request.Timeout = 10_000;

                using (var requestStream = request.GetRequestStream())
                {
                    requestStream.Write(bodyRaw, 0, bodyRaw.Length);
                }

                using var response = (HttpWebResponse)request.GetResponse();
                using var reader = new StreamReader(response.GetResponseStream() ?? throw new InvalidOperationException());
                string text = reader.ReadToEnd();

                return JsonUtility.FromJson<MaxAdReviewKeyResponseModel>(text).api_key;
            }
            catch (Exception e)
            {
                AdReviewHelper.LogError($"Retrieving api key failed. Error: '{e.Message}'");
                return null;
            }
        }
    }
}
#endif
